<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slovní Kvíz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <style>
        /* CSS Variables for theming */
        :root {
            --body-bg: #f0f4f8;
            --container-bg: #ffffff;
            --input-bg: #f0f4f8;
            --text-color: #333;
            --btn-primary-start: #6a11cb;
            --btn-primary-end: #2575fc;
            --btn-secondary-bg: #607d8b;
            --word-card-bg: #e0f2f7;
            --word-card-border: #b3e5fc;
            --word-card-hover-bg: #cce9f5;
            --word-card-selected-bg: #81c784;
            --word-card-selected-border: #66bb6a;
            --word-card-incorrect-bg: #ef9a9a;
            --word-card-incorrect-border: #e57373;
            --point-indicator-default-bg: #9ca3af;
            --point-indicator-achieved-bg: #22c55e;
            --player-current-bg: #d1fae5;
            --player-current-border: #34d399;
            --player-played-bg: #e5e7eb;
            --player-played-border: #9ca3af;
            --player-waiting-bg: #f3f4f6;
            --player-waiting-border: #d1d5db;

            /* Toggle Switch Colors */
            --toggle-bg-off: #cbd5e0; /* gray-300 */
            --toggle-bg-on: #48bb78; /* green-500 */
            --toggle-circle: #ffffff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--body-bg);
            color: var(--text-color); /* Apply text color from variable */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .container {
            background-color: var(--container-bg);
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 900px;
            width: 100%;
            text-align: center;
            position: relative;
        }
        .btn-primary {
            background-image: linear-gradient(to right, var(--btn-primary-start) 0%, var(--btn-primary-end) 100%);
            color: white; /* Ensure text is white */
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        .btn-primary:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .btn-secondary {
            background-color: var(--btn-secondary-bg);
            color: white; /* Ensure text is white */
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        .btn-secondary:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .word-card {
            background-color: var(--word-card-bg);
            border: 1px solid var(--word-card-border);
            padding: 1rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 500;
            user-select: none;
            color: var(--text-color); /* Ensure text color adapts for word cards */
        }
        .word-card:hover {
            background-color: var(--word-card-hover-bg);
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        }
        .word-card.selected {
            background-color: var(--word-card-selected-bg);
            border-color: var(--word-card-selected-border);
            color: white; /* Keep white for selected state for good contrast */
            transform: scale(1.02);
        }
        .word-card.incorrect {
            background-color: var(--word-card-incorrect-bg);
            border-color: var(--word-card-incorrect-border);
            color: white; /* Keep white for incorrect state for good contrast */
            animation: shake 0.5s;
        }
        .word-card.correct-feedback {
            background-color: var(--word-card-selected-bg);
            border-color: var(--word-card-selected-border);
            color: white; /* Keep white for correct feedback state for good contrast */
        }
        @keyframes shake {
            0% { transform: translateX(0); }
            20% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }
        .modal {
            background-color: rgba(0, 0, 0, 0.6);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: var(--container-bg); /* Use container background for modal content */
            color: var(--text-color); /* Use text color for modal content */
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            position: relative;
            max-height: 80vh; /* Make modal content scrollable */
            overflow-y: auto; /* Make modal content scrollable */
        }
        /* Style for message box to be semi-transparent */
        #messageBox {
            background-color: rgba(45, 55, 72, 0.5); /* semi-transparent dark blue-gray */
        }
        .message-box-content {
            background-color: var(--container-bg);
            color: var(--text-color);
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 90%;
            max-width: 500px;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            border-radius: 1.5rem;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-top: 4px solid var(--btn-primary-start);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .point-indicator {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 9999px;
            background-color: var(--point-indicator-default-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }
        .point-indicator.achieved {
            background-color: var(--point-indicator-achieved-bg);
        }
        /* Style for +/- buttons */
        .number-input-group {
            display: flex;
            align-items: center;
        }
        .number-input-group button {
            background-color: #a78bfa; /* purple-400 */
            color: white;
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            font-size: 1.25rem;
            margin: 0 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .number-input-group button:hover {
            background-color: #8b5cf6; /* purple-500 */
        }
        /* Input with confirm button styling */
        .input-with-confirm {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
        }
        .input-with-confirm input {
            flex-grow: 1;
            color: var(--text-color);
            background-color: var(--input-bg); /* UPDATED: Use specific input background */
        }
        .input-with-confirm input:disabled {
            background-color: #e5e7eb;
            cursor: not-allowed;
            color: #6b7280;
        }
        .confirm-btn {
            background-color: #4CAF50; /* Green */
            color: white;
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
        }
        .confirm-btn.edit {
            background-color: #FFC107; /* Amber/Yellow for edit */
        }
        .confirm-btn:hover {
            opacity: 0.9;
        }

        /* Player indicators bar */
        .player-bar-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem;
            border-radius: 0.75rem;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            border: 2px solid transparent;
            min-width: 80px;
            margin: 0 0.25rem;
        }

        .player-bar-item.current-player {
            background-color: var(--player-current-bg);
            border-color: var(--player-current-border);
        }

        .player-bar-item.played-in-round {
            background-color: var(--player-played-bg);
            border-color: var(--player-played-border);
        }

        .player-bar-item.waiting {
            background-color: var(--player-waiting-bg);
            border-color: var(--player-waiting-border);
        }

        .player-bar-name {
            font-weight: bold;
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            color: var(--text-color); /* Ensure name text color adapts */
        }

        .player-bar-score {
            font-size: 0.75rem;
            color: #6b7280; /* gray-500 - fixed for score text contrast, works on both light/dark backgrounds */
        }
        .color-input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .color-input-group label {
            flex-shrink: 0;
            width: 180px; /* Increased width for longer labels */
            text-align: right;
            margin-right: 0.5rem;
            color: var(--text-color); /* Ensure label text color adapts */
        }
        .color-input-group input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            cursor: pointer;
            padding: 0;
            background: none;
        }
        .color-input-group input[type="text"] {
            flex-grow: 1;
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-color); /* Ensure text color adapts */
            background-color: var(--container-bg); /* Ensure background adapts */
        }

        /* Toggle Switch CSS */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem; /* Space between toggle and info */
        }
        .toggle-switch-label {
            color: var(--text-color); /* Use dynamic text color for label */
            font-weight: bold;
            font-size: 0.875rem; /* text-sm */
            margin-right: 1rem; /* Space between label and switch */
            flex-grow: 1;
            text-align: left;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            flex-shrink: 0; /* Prevent it from shrinking */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--toggle-bg-off);
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: var(--toggle-circle);
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--toggle-bg-on);
        }

        input:focus + .toggle-slider {
            box-shadow: 0 0 1px var(--toggle-bg-on);
        }

        input:checked + .toggle-slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }

        .toggle-info {
            font-size: 0.75rem; /* text-xs */
            color: var(--text-color); /* Use general text color */
            margin-top: 0.25rem;
            text-align: left;
        }
    </style>
</head>
<body class="bg-gray-100 p-4 sm:p-6 md:p-8">

    <div class="container relative">
        <!-- Rules Button -->
        <button id="rulesBtn" class="absolute top-4 left-4 text-gray-600 hover:text-gray-800 focus:outline-none p-2 rounded-full bg-gray-100 hover:bg-gray-200 transition-colors duration-200">
            <i class="fas fa-info-circle text-2xl"></i>
        </button>

        <!-- Top Right Controls -->
        <div class="absolute top-4 right-4 flex items-center gap-2">
             <span id="apiKeyHintLink" class="text-sm text-gray-500 hover:text-gray-800 cursor-pointer font-semibold">
                 <!-- text set by JS -->
             </span>
            <button id="settingsBtn" class="text-gray-600 hover:text-gray-800 focus:outline-none p-2 rounded-full bg-gray-100 hover:bg-gray-200 transition-colors duration-200">
                <i class="fas fa-cog text-2xl"></i>
            </button>
        </div>


        <h1 id="gameTitle" class="text-4xl font-extrabold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-blue-500">Slovní Kvíz</h1>

        <!-- Game Setup Screen -->
        <div id="setupScreen" class="space-y-6">
            <div class="flex flex-col sm:flex-row justify-center items-center space-y-4 sm:space-y-0 sm:space-x-8">
                <div class="flex flex-col items-center">
                    <label for="numPlayers" id="labelNumPlayers" class="text-lg font-semibold mb-2">Počet hráčů:</label>
                    <div class="number-input-group">
                        <button id="decrementPlayers">-</button>
                        <input type="number" id="numPlayers" value="1" min="1" class="w-24 p-3 border border-gray-300 rounded-lg text-center text-xl focus:ring-2 focus:ring-blue-400">
                        <button id="incrementPlayers">+</button>
                    </div>
                </div>
                <div class="flex flex-col items-center">
                    <label for="numRounds" id="labelNumRounds" class="text-lg font-semibold mb-2">Počet kol:</label>
                    <div class="number-input-group">
                        <button id="decrementRounds">-</button>
                        <input type="number" id="numRounds" value="3" min="1" class="w-24 p-3 border border-gray-300 rounded-lg text-center text-xl focus:ring-2 focus:ring-blue-400">
                        <button id="incrementRounds">+</button>
                    </div>
                </div>
            </div>
            <div id="playerNamesContainer" class="mt-6 space-y-4 max-w-sm mx-auto">
                <!-- Player name inputs will be dynamically added here -->
            </div>
            <button id="startGameBtn" class="btn-primary mt-8">Spustit Hru</button>
        </div>

        <!-- Game Play Screen -->
        <div id="gamePlayScreen" class="hidden">
            <div class="mb-6">
                <p class="text-lg font-bold"><span id="labelTextPlayer">Hráč</span>: <span id="currentPlayerName"></span></p>
                <p class="text-lg font-bold"><span id="labelTextRound">Kolo</span>: <span id="currentRoundDisplay"></span> / <span id="totalRoundsDisplay"></span></p>
                <p class="text-lg font-bold"><span id="labelTextScore">Skóre</span>: <span id="currentScoreDisplay"></span></p>
            </div>

            <!-- Player Indicators Bar -->
            <div id="playerIndicatorsBar" class="flex justify-center flex-wrap gap-2 mb-6">
                <!-- Player items will be injected here -->
            </div>


            <div id="loadingOverlay" class="loading-overlay hidden">
                <div class="spinner"></div>
                <p id="loadingText" class="ml-4 text-xl font-semibold text-gray-700 mt-4">Generuji otázku...</p>
            </div>

            <h2 id="questionDisplay" class="text-2xl font-bold mb-6 text-gray-800"></h2>

            <!-- Point Indicators -->
            <div id="pointIndicatorsContainer" class="flex justify-center space-x-2 mb-4">
                <div id="point1" class="point-indicator">1</div>
                <div id="point2" class="point-indicator">2</div>
                <div id="point3" class="point-indicator">4</div>
                <div id="point4" class="point-indicator">6</div>
                <div id="point5" class="point-indicator">8</div>
            </div>

            <div id="wordsContainer" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 mb-6">
                <!-- Words will be injected here -->
            </div>

            <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4">
                <button id="endRoundBtn" class="btn-secondary"></button>
            </div>
        </div>

        <!-- Game End Screen -->
        <div id="gameEndScreen" class="hidden">
            <h2 id="gameEndTitle" class="text-3xl font-bold mb-6 text-green-700">Hra Ukončena!</h2>
            <h3 id="finalScoreTitle" class="text-2xl font-semibold mb-4">Konečné skóre:</h3>
            <div id="finalScores" class="text-lg font-medium mb-6">
                <!-- Final scores will be displayed here -->
            </div>
            <button id="newGameBtnEnd" class="btn-primary"></button>
        </div>

        <!-- Message Box (Blocking - requires OK click) -->
        <div id="messageBox" class="hidden fixed inset-0 flex items-center justify-center p-4 z-1000">
            <div class="message-box-content">
                <p id="messageText" class="text-xl font-semibold mb-4"></p>
                <button id="messageBoxCloseBtn" class="btn-primary"></button>
            </div>
        </div>
    </div>

    <!-- Rules Modal (New) -->
    <div id="rulesModal" class="modal hidden">
        <div class="modal-content">
            <h3 id="rulesModalTitle" class="text-2xl font-bold mb-4">Pravidla Hry</h3>
            <div id="rulesContent" class="text-left text-base mb-6 space-y-3">
                <p>Vítejte ve Slovním Kvízu!</p>
                <p>1. Na začátku hry si zvolte počet hráčů a počet kol. Každý hráč si může zadat své jméno.</p>
                <p>2. V každém kole se zobrazí jedna otázka a 10 slov. Vaším úkolem je vybrat 5 správných odpovědí z nabídky.</p>
                <p>3. Za každou správně vybranou odpověď získáváte body: 1, 2, 4, 6, 8. Body se přičítají postupně za první, druhou, třetí, čtvrtou a pátou správnou volbu.</p>
                <p>4. Pokud vyberete špatné slovo, váš tah okamžitě končí a za toto kolo nezískáte žádné body.</p>
                <p>5. Můžete také kdykoli ukončit svůj tah tlačítkem "Ukončit Kolo a Získat Body" a ponechat si body, které jste do té doby nasbírali.</p>
                <p>6. Po skončení tahu se zobrazí zpráva s vaším bodovým ziskem. Kliknutím na "OK" potvrdíte a posunete hru dál.</p>
                <p>7. Všichni hráči v daném kole odpovídají na stejnou otázku.</p>
                <p>8. Po odehrání všech hráčů v kole se zobrazí souhrn kol, který ukáže průběžné skóre. Poté se vygeneruje nová otázka pro další kolo.</p>
                <p>9. V nastavení můžete změnit jazyk hry, zadat vlastní API klíč pro AI (volitelné), nastavit žánr otázek a přizpůsobit barevné schéma hry.</p>
                <p>Přejeme hodně štěstí!</p>
            </div>
            <button id="closeRulesBtn" class="btn-primary"></button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <h3 id="settingsTitle" class="text-2xl font-bold mb-4">Nastavení</h3>
            
            <div class="mb-4 text-left">
                <label for="languageSelect" id="labelLanguage" class="block text-gray-700 text-sm font-bold mb-2">
                    Jazyk:
                </label>
                <select id="languageSelect" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    <option value="cs">Čeština</option>
                    <option value="en">English</option>
                </select>
            </div>

             <!-- NEW: Difficulty Setting -->
            <div class="mb-4 text-left">
                <label for="difficultySelect" id="labelDifficulty" class="block text-gray-700 text-sm font-bold mb-2">
                    Obtížnost:
                </label>
                <select id="difficultySelect" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    <option value="easy">Lehká</option>
                    <option value="medium">Střední</option>
                    <option value="hard">Těžká</option>
                </select>
            </div>

            <!-- General Show Correct Answers Toggle -->
            <div class="toggle-switch-container">
                <label for="generalShowCorrectAnswersFeedbackToggle" id="labelGeneralShowCorrectAnswersFeedback" class="toggle-switch-label">
                    Zobrazit správné odpovědi po kole
                </label>
                <label class="toggle-switch">
                    <input type="checkbox" id="generalShowCorrectAnswersFeedbackToggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <p id="generalShowCorrectAnswersFeedbackInfo" class="toggle-info mb-4"></p>

            <!-- Genre and API Key Settings -->
            <div class="mb-4 text-left">
                <label for="genrePromptInput" id="labelGenrePrompt" class="block text-gray-700 text-sm font-bold mb-2">
                    Žánr otázek (např. historie, věda):
                </label>
                <div class="input-with-confirm">
                    <input type="text" id="genrePromptInput" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Např. historie, věda, filmy">
                    <button id="confirmGenreBtn" class="confirm-btn"><i class="fas fa-check"></i></button>
                </div>
                <p id="genreHint" class="text-xs text-gray-500 mt-1">Pokud prázdné, otázky budou náhodné.</p>
            </div>
            <div class="mb-4 text-left">
                <label for="geminiApiKeyInput" id="labelGeminiApiKey" class="block text-gray-700 text-sm font-bold mb-2">
                    Gemini API Klíč:
                </label>
                <div class="input-with-confirm">
                    <input type="text" id="geminiApiKeyInput" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Vložte svůj Gemini API klíč">
                    <button id="confirmApiKeyBtn" class="confirm-btn"><i class="fas fa-check"></i></button>
                </div>
                <p id="apiKeyHint" class="text-xs text-gray-500 mt-1">Pokud klíč nezadáte, bude použito výchozí nastavení (může být omezeno).</p>
                <p class="text-xs text-gray-500 mt-1">
                    <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-500 hover:underline">Získat Gemini API klíč zde</a>
                </p>
            </div>

            <!-- Color Theme Settings -->
            <h4 id="colorThemeTitle" class="text-xl font-bold mb-3 mt-6">Barevné schéma</h4>
            <div class="mb-4 text-left">
                <label id="presetThemeLabel" class="block text-gray-700 text-sm font-bold mb-2">Přednastavená témata:</label>
                <div class="flex flex-wrap gap-3">
                    <label class="inline-flex items-center">
                        <input type="radio" name="themePreset" value="purpleBlueGradient" class="form-radio text-blue-600 h-4 w-4" checked>
                        <span id="presetThemeDefault" class="ml-2 text-gray-700">Fialovo-modrý gradient</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="themePreset" value="light" class="form-radio text-blue-600 h-4 w-4">
                        <span id="presetThemeLight" class="ml-2 text-gray-700">Světlý</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="themePreset" value="dark" class="form-radio text-blue-600 h-4 w-4">
                        <span id="presetThemeDark" class="ml-2 text-gray-700">Tmavý</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="themePreset" value="custom" class="form-radio text-blue-600 h-4 w-4">
                        <span id="presetThemeCustom" class="ml-2 text-gray-700">Vlastní</span>
                    </label>
                </div>
            </div>

            <div id="customColorsSection" class="mb-4 text-left border-t border-gray-200 pt-4 hidden">
                <h5 id="customColorsTitle" class="text-md font-bold mb-2">Vlastní barvy rozhraní:</h5>
                <div class="color-input-group">
                    <label for="colorBodyBg"></label>
                    <input type="color" id="colorBodyBg">
                    <input type="text" id="hexColorBodyBg">
                </div>
                <div class="color-input-group">
                    <label for="colorContainerBg"></label>
                    <input type="color" id="colorContainerBg">
                    <input type="text" id="hexColorContainerBg">
                </div>
                <div class="color-input-group">
                    <label for="colorInputBg"></label>
                    <input type="color" id="colorInputBg">
                    <input type="text" id="hexColorInputBg">
                </div>
                <div class="color-input-group">
                    <label for="colorText"></label>
                    <input type="color" id="colorText">
                    <input type="text" id="hexColorText">
                </div>
                <div class="color-input-group">
                    <label for="colorPrimaryBtnStart"></label>
                    <input type="color" id="colorPrimaryBtnStart">
                    <input type="text" id="hexColorPrimaryBtnStart">
                </div>
                <div class="color-input-group">
                    <label for="colorPrimaryBtnEnd"></label>
                    <input type="color" id="colorPrimaryBtnEnd">
                    <input type="text" id="hexColorPrimaryBtnEnd">
                </div>
                <div class="color-input-group">
                    <label for="colorSecondaryBtnBg"></label>
                    <input type="color" id="colorSecondaryBtnBg">
                    <input type="text" id="hexColorSecondaryBtnBg">
                </div>
                <div class="color-input-group">
                    <label for="colorWordCardBg"></label>
                    <input type="color" id="colorWordCardBg">
                    <input type="text" id="hexColorWordCardBg">
                </div>
                <div class="color-input-group">
                    <label for="colorWordCardBorder"></label>
                    <input type="color" id="colorWordCardBorder">
                    <input type="text" id="hexColorWordCardBorder">
                </div>
                <div class="color-input-group">
                    <label for="colorWordCardSelectedBg"></label>
                    <input type="color" id="colorWordCardSelectedBg">
                    <input type="text" id="hexColorWordCardSelectedBg">
                </div>
                 <div class="color-input-group">
                    <label for="colorWordCardSelectedBorder"></label>
                    <input type="color" id="colorWordCardSelectedBorder">
                    <input type="text" id="hexColorWordCardSelectedBorder">
                </div>
                <div class="color-input-group">
                    <label for="colorWordCardIncorrectBg"></label>
                    <input type="color" id="colorWordCardIncorrectBg">
                    <input type="text" id="hexColorWordCardIncorrectBg">
                </div>
                <div class="color-input-group">
                    <label for="colorWordCardIncorrectBorder"></label>
                    <input type="color" id="colorWordCardIncorrectBorder">
                    <input type="text" id="hexColorWordCardIncorrectBorder">
                </div>
                <button id="resetColorsBtn" class="btn-secondary mt-4 w-full">Restartovat nastavení barev</button>
            </div>

            <p id="versionInfo" class="text-sm text-gray-500 mt-4"></p>

            <div class="flex justify-between mt-6">
                <button id="newGameBtnSettings" class="btn-primary"></button>
                <button id="closeSettingsBtn" class="btn-secondary"></button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal hidden">
        <div class="modal-content">
            <h3 id="confirmationTitle" class="text-2xl font-bold mb-4">Potvrzení</h3>
            <p id="confirmationText" class="text-xl mb-6"></p>
            <div class="flex justify-center space-x-4">
                <button id="confirmYesBtn" class="btn-primary">Ano</button>
                <button id="confirmNoBtn" class="btn-secondary">Ne</button>
            </div>
        </div>
    </div>

    <!-- Round Summary Modal -->
    <div id="roundSummaryModal" class="modal hidden">
        <div class="modal-content">
            <h3 id="roundSummaryTitle" class="text-2xl font-bold mb-4">Souhrn Kola</h3>
            <div id="roundSummaryScores" class="text-lg font-medium mb-6">
                <!-- Round summary scores will be displayed here -->
            </div>
            <button id="continueGameBtn" class="btn-primary"></button>
        </div>
    </div>

    <script type="module">
        // Global variables for Firebase (not used in this version but kept as template)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';

        // Game Version
        const GAME_VERSION = "v1.14"; // UPDATED: Version increased

        // --- Localization Dictionary ---
        const translations = {
            cs: {
                gameTitle: "Slovní Kvíz",
                labelNumPlayers: "Počet hráčů:",
                labelNumRounds: "Počet kol:",
                startGameBtn: "Spustit Hru",
                labelTextPlayer: "Hráč",
                labelTextRound: "Kolo",
                labelTextScore: "Skóre",
                loadingText: "Generuji otázku...",
                endRoundBtn: "Ukončit Kolo a Získat Body",
                gameEndTitle: "Hra Ukončena!",
                finalScoreTitle: "Konečné skóre:",
                newGameBtnEnd: "Nová Hra",
                messageBoxCloseBtn: "OK",
                settingsTitle: "Nastavení",
                labelLanguage: "Jazyk:",
                labelDifficulty: "Obtížnost:",
                difficultyEasy: "Lehká",
                difficultyMedium: "Střední",
                difficultyHard: "Těžká",
                labelGeneralShowCorrectAnswersFeedback: "Zobrazit správné odpovědi po kole",
                infoGeneralShowCorrectAnswersFeedback: "Toto nastavení se projeví na začátku dalšího kola.",
                labelGenrePrompt: "Žánr otázek (např. historie, věda):",
                genreHint: "Pokud prázdné, otázky budou náhodné.",
                labelGeminiApiKey: "Gemini API Klíč:",
                apiKeyHint: "Pokud klíč nezadáte, bude použito výchozí nastavení (může být omezeno).",
                apiKeySetupLink: "zadej API >",
                getApiKeyLink: "Získat Gemini API klíč zde",
                newGameBtnSettings: "Nová Hra",
                closeSettingsBtn: "Zavřít",
                playerPlaceholder: "Jméno hráče",
                playerInvalidNum: "Prosím zadejte platný počet hráčů (minimálně 1).",
                roundInvalidNum: "Prosím zadejte platný počet kol (minimálně 1).",
                aiError: "Chyba při generování otázky: ",
                aiNoResponse: "Žádná platná odpověď z AI. Prosím zkuste to znovu.",
                aiInvalidStructure: "Neplatná struktura odpovědi od AI. Prosím zkuste to znovu.",
                allCorrectMessage: "Vybrali jste všech 5 správných odpovědí! Kolo ukončeno. Získal(a) jste {points} bodů.",
                incorrectAnswerMessage: (playerName) => `Špatná odpověď! Kolo pro ${playerName} končí. Získáváte 0 bodů za toto kolo.`,
                endTurnMessage: (playerName, points) => `Konec tahu pro ${playerName}. Získal(a) ${points} bodů.`,
                roundSummaryTitle: "Souhrn Kola",
                roundSummaryScorePrefix: "Celkové skóre: ",
                roundSummaryRoundPointsPrefix: "Body za kolo: ",
                continueGameBtn: "Pokračovat",
                endRoundEarlyMessage: (playerName, points) => `Kolo ukončeno dříve pro ${playerName}. Získal(a) ${points} bodů.`,
                nextPlayerMessage: (nextPlayerName) => `Nyní hraje ${nextPlayerName}.`,
                gameFinishedMessage: "Hra ukončena! Zobrazuji konečné výsledky.",
                playerNameRequired: "Prosím zadejte a potvrďte jména všech hráčů.",
                confirmationTitle: "Potvrzení nové hry",
                confirmationText: "Opravdu chcete začít novou hru? Veškerý aktuální průběh bude ztracen.",
                confirmYes: "Ano",
                confirmNo: "Ne",
                confirmName: "Potvrdit jméno",
                rulesBtnText: "Pravidla",
                rulesModalTitle: "Pravidla Hry",
                versionInfoText: "Verze:",
                colorThemeTitle: "Barevné schéma",
                presetThemeLabel: "Přednastavená témata:",
                presetThemeDefault: "Fialovo-modrý gradient",
                presetThemeLight: "Světlý",
                presetThemeDark: "Tmavý",
                presetThemeCustom: "Vlastní",
                customColorsTitle: "Vlastní barvy rozhraní:",
                colorBodyBg: "Pozadí stránky:",
                colorContainerBg: "Pozadí kontejneru:",
                colorInputBg: "Pozadí vstupních polí:",
                colorText: "Barva textu:",
                colorPrimaryBtnStart: "Prim. tlačítko (start):",
                colorPrimaryBtnEnd: "Prim. tlačítko (konec):",
                colorSecondaryBtnBg: "Sek. tlačítko (pozadí):",
                colorWordCardBg: "Kartička (pozadí):",
                colorWordCardBorder: "Kartička (rámeček):",
                colorWordCardSelectedBg: "Vybraná kartička (pozadí):",
                colorWordCardSelectedBorder: "Vybraná kartička (rámeček):",
                colorWordCardIncorrectBg: "Špatná kartička (pozadí):",
                colorWordCardIncorrectBorder: "Špatná kartička (rámeček):",
                resetColorsBtn: "Restartovat nastavení barev"
            },
            en: {
                gameTitle: "Word Quiz",
                labelNumPlayers: "Number of Players:",
                labelNumRounds: "Number of Rounds:",
                startGameBtn: "Start Game",
                labelTextPlayer: "Player",
                labelTextRound: "Round",
                labelTextScore: "Score",
                loadingText: "Generating question...",
                endRoundBtn: "End Round and Get Points",
                gameEndTitle: "Game Over!",
                finalScoreTitle: "Final Scores:",
                newGameBtnEnd: "New Game",
                messageBoxCloseBtn: "OK",
                settingsTitle: "Settings",
                labelLanguage: "Language:",
                labelDifficulty: "Difficulty:",
                difficultyEasy: "Easy",
                difficultyMedium: "Medium",
                difficultyHard: "Hard",
                labelGeneralShowCorrectAnswersFeedback: "Show correct answers after round",
                infoGeneralShowCorrectAnswersFeedback: "This setting will apply at the start of the next round.",
                labelGenrePrompt: "Question Genre (e.g. history, science):",
                genreHint: "If empty, questions will be random.",
                labelGeminiApiKey: "Gemini API Key:",
                apiKeyHint: "If no key is provided, default settings will be used (may be limited).",
                apiKeySetupLink: "set API key >",
                getApiKeyLink: "Get Gemini API key here",
                newGameBtnSettings: "New Game",
                closeSettingsBtn: "Close",
                playerPlaceholder: "Player Name",
                playerInvalidNum: "Please enter a valid number of players (minimum 1).",
                roundInvalidNum: "Please enter a valid number of rounds (minimum 1).",
                aiError: "Error generating question: ",
                aiNoResponse: "No valid response from AI. Please try again.",
                aiInvalidStructure: "Invalid response structure from AI. Please try again.",
                allCorrectMessage: "You selected all 5 correct answers! Round ended. You earned {points} points.",
                incorrectAnswerMessage: (playerName) => `Incorrect answer! Round ends for ${playerName}. You get 0 points for this round.`,
                endTurnMessage: (playerName, points) => `Turn ended for ${playerName}. Earned ${points} points.`,
                roundSummaryTitle: "Round Summary",
                roundSummaryScorePrefix: "Total Score: ",
                roundSummaryRoundPointsPrefix: "Round Points: ",
                continueGameBtn: "Continue",
                endRoundEarlyMessage: (playerName, points) => `Round ended early for ${playerName}. Earned ${points} points.`,
                nextPlayerMessage: (nextPlayerName) => `Now playing: ${nextPlayerName}.`,
                gameFinishedMessage: "Game Over! Displaying final results.",
                playerNameRequired: "Please enter and confirm all player names.",
                confirmationTitle: "Confirm New Game",
                confirmationText: "Are you sure you want to start a new game? All current progress will be lost.",
                confirmYes: "Yes",
                confirmNo: "No",
                confirmName: "Confirm Name",
                rulesBtnText: "Rules",
                rulesModalTitle: "Game Rules",
                versionInfoText: "Version:",
                colorThemeTitle: "Color Theme",
                presetThemeLabel: "Preset Themes:",
                presetThemeDefault: "Purple-Blue Gradient",
                presetThemeLight: "Light",
                presetThemeDark: "Dark",
                presetThemeCustom: "Custom",
                customColorsTitle: "Custom Interface Colors:",
                colorBodyBg: "Page Background:",
                colorContainerBg: "Container Background:",
                colorInputBg: "Input Fields Background:",
                colorText: "Text Color:",
                colorPrimaryBtnStart: "Primary Button (Start):",
                colorPrimaryBtnEnd: "Primary Button (End):",
                colorSecondaryBtnBg: "Secondary Button (BG):",
                colorWordCardBg: "Card (Background):",
                colorWordCardBorder: "Card (Border):",
                colorWordCardSelectedBg: "Selected Card (BG):",
                colorWordCardSelectedBorder: "Selected Card (Border):",
                colorWordCardIncorrectBg: "Incorrect Card (BG):",
                colorWordCardIncorrectBorder: "Incorrect Card (Border):",
                resetColorsBtn: "Reset Color Settings"
            }
        };

        // DOM Elements
        const setupScreen = document.getElementById('setupScreen');
        const gamePlayScreen = document.getElementById('gamePlayScreen');
        const gameEndScreen = document.getElementById('gameEndScreen');
        const numPlayersInput = document.getElementById('numPlayers');
        const numRoundsInput = document.getElementById('numRounds');
        const playerNamesContainer = document.getElementById('playerNamesContainer');
        const startGameBtn = document.getElementById('startGameBtn');
        const currentPlayerNameDisplay = document.getElementById('currentPlayerName');
        const currentRoundDisplay = document.getElementById('currentRoundDisplay');
        const totalRoundsDisplay = document.getElementById('totalRoundsDisplay');
        const currentScoreDisplay = document.getElementById('currentScoreDisplay');
        const questionDisplay = document.getElementById('questionDisplay');
        const wordsContainer = document.getElementById('wordsContainer');
        const endRoundBtn = document.getElementById('endRoundBtn');
        const finalScoresDisplay = document.getElementById('finalScores');
        const newGameBtnEnd = document.getElementById('newGameBtnEnd');
        const settingsBtn = document.getElementById('settingsBtn');
        const apiKeyHintLink = document.getElementById('apiKeyHintLink');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');
        const newGameBtnSettings = document.getElementById('newGameBtnSettings');
        const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
        const languageSelect = document.getElementById('languageSelect');
        const difficultySelect = document.getElementById('difficultySelect'); // NEW
        const generalShowCorrectAnswersFeedbackToggle = document.getElementById('generalShowCorrectAnswersFeedbackToggle');
        const generalShowCorrectAnswersFeedbackInfo = document.getElementById('generalShowCorrectAnswersFeedbackInfo');
        const genrePromptInput = document.getElementById('genrePromptInput');
        const confirmGenreBtn = document.getElementById('confirmGenreBtn');
        const confirmApiKeyBtn = document.getElementById('confirmApiKeyBtn');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageBoxCloseBtn = document.getElementById('messageBoxCloseBtn');
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmationTitle = document.getElementById('confirmationTitle');
        const confirmationText = document.getElementById('confirmationText');
        const confirmYesBtn = document.getElementById('confirmYesBtn');
        const confirmNoBtn = document.getElementById('confirmNoBtn');
        const roundSummaryModal = document.getElementById('roundSummaryModal');
        const roundSummaryTitle = document.getElementById('roundSummaryTitle');
        const roundSummaryScores = document.getElementById('roundSummaryScores');
        const continueGameBtn = document.getElementById('continueGameBtn');
        const pointIndicators = [
            document.getElementById('point1'),
            document.getElementById('point2'),
            document.getElementById('point3'),
            document.getElementById('point4'),
            document.getElementById('point5')
        ];
        const decrementPlayersBtn = document.getElementById('decrementPlayers');
        const incrementPlayersBtn = document.getElementById('incrementPlayers');
        const decrementRoundsBtn = document.getElementById('decrementRounds');
        const incrementRoundsBtn = document.getElementById('incrementRounds');
        const playerIndicatorsBar = document.getElementById('playerIndicatorsBar');
        const rulesBtn = document.getElementById('rulesBtn');
        const rulesModal = document.getElementById('rulesModal');
        const closeRulesBtn = document.getElementById('closeRulesBtn');
        const rulesModalTitle = document.getElementById('rulesModalTitle');
        const themePresetRadios = document.querySelectorAll('input[name="themePreset"]');
        const customColorsSection = document.getElementById('customColorsSection');

        const colorInputs = {
            bodyBg: document.getElementById('colorBodyBg'),
            containerBg: document.getElementById('colorContainerBg'),
            inputBg: document.getElementById('colorInputBg'),
            text: document.getElementById('colorText'),
            primaryBtnStart: document.getElementById('colorPrimaryBtnStart'),
            primaryBtnEnd: document.getElementById('colorPrimaryBtnEnd'),
            secondaryBtnBg: document.getElementById('colorSecondaryBtnBg'),
            wordCardBg: document.getElementById('colorWordCardBg'),
            wordCardBorder: document.getElementById('colorWordCardBorder'),
            wordCardSelectedBg: document.getElementById('colorWordCardSelectedBg'),
            wordCardSelectedBorder: document.getElementById('colorWordCardSelectedBorder'),
            wordCardIncorrectBg: document.getElementById('colorWordCardIncorrectBg'),
            wordCardIncorrectBorder: document.getElementById('colorWordCardIncorrectBorder'),
        };
        const hexColorInputs = {
            bodyBg: document.getElementById('hexColorBodyBg'),
            containerBg: document.getElementById('hexColorContainerBg'),
            inputBg: document.getElementById('hexColorInputBg'),
            text: document.getElementById('hexColorText'),
            primaryBtnStart: document.getElementById('hexColorPrimaryBtnStart'),
            primaryBtnEnd: document.getElementById('hexColorPrimaryBtnEnd'),
            secondaryBtnBg: document.getElementById('hexColorSecondaryBtnBg'),
            wordCardBg: document.getElementById('hexColorWordCardBg'),
            wordCardBorder: document.getElementById('hexColorWordCardBorder'),
            wordCardSelectedBg: document.getElementById('hexColorWordCardSelectedBg'),
            wordCardSelectedBorder: document.getElementById('hexColorWordCardSelectedBorder'),
            wordCardIncorrectBg: document.getElementById('hexColorWordCardIncorrectBg'),
            wordCardIncorrectBorder: document.getElementById('hexColorWordCardIncorrectBorder'),
        };
        const versionInfoElement = document.getElementById('versionInfo');
        const resetColorsBtn = document.getElementById('resetColorsBtn');

        // Game State Variables
        let gameConfig = { numPlayers: 1, numRounds: 3 };
        let players = [];
        let currentPlayerIndex = 0;
        let currentRound = 1;
        let selectedWords = [];
        let correctWordsInRound = [];
        let scorePerCorrectChoice = [1, 2, 4, 6, 8];
        let currentRoundCorrectCount = 0;
        let currentTurnEarnedPoints = 0;
        let gameActive = false;
        let geminiApiKey = "";
        let gameLanguage = "cs";
        let difficulty = "medium"; // NEW
        let nextRoundDifficulty = "medium"; // NEW
        let generalShowCorrectAnswersFeedback = true; 
        let nextRoundGeneralShowCorrectAnswersFeedback = true;
        let genrePrompt = "";
        let usedQuestions = new Set();
        let currentQuestionData = null; 
        let currentTheme = 'purpleBlueGradient';
        let customColors = {};

        const themes = {
            light: {
                bodyBg: '#f0f4f8', containerBg: '#ffffff', inputBg: '#f0f4f8', text: '#333333',
                primaryBtnStart: '#6a11cb', primaryBtnEnd: '#2575fc', secondaryBtnBg: '#607d8b',
                wordCardBg: '#e0f2f7', wordCardBorder: '#b3e5fc', wordCardHover: '#cce9f5',
                wordCardSelectedBg: '#81c784', wordCardSelectedBorder: '#66bb6a',
                wordCardIncorrectBg: '#ef9a9a', wordCardIncorrectBorder: '#e57373',
                pointIndicatorDefault: '#9ca3af', pointIndicatorAchieved: '#22c55e',
                playerCurrentBg: '#d1fae5', playerCurrentBorder: '#34d399',
                playerPlayedBg: '#e5e7eb', playerPlayedBorder: '#9ca3af',
                playerWaitingBg: '#f3f4f6', playerWaitingBorder: '#d1d5db'
            },
            dark: {
                bodyBg: '#2d3748', containerBg: '#4a5568', inputBg: '#2d3748', text: '#e2e8f0',
                primaryBtnStart: '#7f00ff', primaryBtnEnd: '#e100ff', secondaryBtnBg: '#607d8b',
                wordCardBg: '#2f3b4d', wordCardBorder: '#4a5568', wordCardHover: '#4a5568',
                wordCardSelectedBg: '#38a169', wordCardSelectedBorder: '#2f855a',
                wordCardIncorrectBg: '#e53e3e', wordCardIncorrectBorder: '#c53030',
                pointIndicatorDefault: '#a0aec0', pointIndicatorAchieved: '#48bb78',
                playerCurrentBg: '#2d3748', playerCurrentBorder: '#4c7878',
                playerPlayedBg: '#4a5568', playerPlayedBorder: '#718096',
                playerWaitingBg: '#2d3748', playerWaitingBorder: '#6a7280'
            },
            purpleBlueGradient: {
                 bodyBg: '#f0f4f8', containerBg: '#ffffff', inputBg: '#f0f4f8', text: '#333333',
                primaryBtnStart: '#6a11cb', primaryBtnEnd: '#2575fc', secondaryBtnBg: '#607d8b',
                wordCardBg: '#e0f2f7', wordCardBorder: '#b3e5fc', wordCardHover: '#cce9f5',
                wordCardSelectedBg: '#81c784', wordCardSelectedBorder: '#66bb6a',
                wordCardIncorrectBg: '#ef9a9a', wordCardIncorrectBorder: '#e57373',
                pointIndicatorDefault: '#9ca3af', pointIndicatorAchieved: '#22c55e',
                playerCurrentBg: '#d1fae5', playerCurrentBorder: '#34d399',
                playerPlayedBg: '#e5e7eb', playerPlayedBorder: '#9ca3af',
                playerWaitingBg: '#f3f4f6', playerWaitingBorder: '#d1d5db'
            }
        };

        // --- Utility Functions ---

        /**
         * Applies the selected theme or custom colors to the CSS variables.
         */
        function applyTheme(themeName) {
            let activeColors;
            if (themeName === 'custom') {
                activeColors = { ...themes.light, ...customColors };
            } else {
                activeColors = themes[themeName];
            }

            document.documentElement.style.setProperty('--body-bg', activeColors.bodyBg);
            document.documentElement.style.setProperty('--container-bg', activeColors.containerBg);
            document.documentElement.style.setProperty('--input-bg', activeColors.inputBg);
            document.documentElement.style.setProperty('--text-color', activeColors.text);
            document.documentElement.style.setProperty('--btn-primary-start', activeColors.primaryBtnStart);
            document.documentElement.style.setProperty('--btn-primary-end', activeColors.primaryBtnEnd);
            document.documentElement.style.setProperty('--btn-secondary-bg', activeColors.secondaryBtnBg);
            document.documentElement.style.setProperty('--word-card-bg', activeColors.wordCardBg);
            document.documentElement.style.setProperty('--word-card-border', activeColors.wordCardBorder);
            document.documentElement.style.setProperty('--word-card-hover-bg', activeColors.wordCardHover);
            document.documentElement.style.setProperty('--word-card-selected-bg', activeColors.wordCardSelectedBg);
            document.documentElement.style.setProperty('--word-card-selected-border', activeColors.wordCardSelectedBorder);
            document.documentElement.style.setProperty('--word-card-incorrect-bg', activeColors.wordCardIncorrectBg);
            document.documentElement.style.setProperty('--word-card-incorrect-border', activeColors.wordCardIncorrectBorder);
            document.documentElement.style.setProperty('--point-indicator-default-bg', activeColors.pointIndicatorDefault);
            document.documentElement.style.setProperty('--point-indicator-achieved-bg', activeColors.pointIndicatorAchieved);
            document.documentElement.style.setProperty('--player-current-bg', activeColors.playerCurrentBg);
            document.documentElement.style.setProperty('--player-current-border', activeColors.playerCurrentBorder);
            document.documentElement.style.setProperty('--player-played-bg', activeColors.playerPlayedBg);
            document.documentElement.style.setProperty('--player-played-border', activeColors.playerPlayedBorder);
            document.documentElement.style.setProperty('--player-waiting-bg', activeColors.playerWaitingBg);
            document.documentElement.style.setProperty('--player-waiting-border', activeColors.playerWaitingBorder);

            currentTheme = themeName;
            localStorage.setItem('gameTheme', themeName);
            if (themeName === 'custom') {
                localStorage.setItem('customColors', JSON.stringify(customColors));
            } else {
                localStorage.removeItem('customColors');
            }
        }

        /**
         * Loads color settings from localStorage and applies them.
         */
        function loadThemeSettings() {
            const storedTheme = localStorage.getItem('gameTheme');
            const storedCustomColors = localStorage.getItem('customColors');

            if (storedCustomColors) {
                try {
                    const loadedColors = JSON.parse(storedCustomColors);
                    customColors = { ...themes.light, ...loadedColors };

                    for (const key in colorInputs) {
                        if (colorInputs[key] && customColors[key]) {
                            colorInputs[key].value = customColors[key];
                            hexColorInputs[key].value = customColors[key];
                        }
                    }
                    document.querySelector('input[name="themePreset"][value="custom"]').checked = true;
                    customColorsSection.classList.remove('hidden');
                    applyTheme('custom');
                } catch (e) {
                    console.error("Error parsing custom colors from localStorage:", e);
                    applyTheme('purpleBlueGradient');
                }
            } else if (storedTheme && themes[storedTheme]) {
                document.querySelector(`input[name="themePreset"][value="${storedTheme}"]`).checked = true;
                customColorsSection.classList.add('hidden');
                applyTheme(storedTheme);
            } else {
                applyTheme('purpleBlueGradient');
            }
        }

        /**
         * Helper function to safely get an element.
         */
        function getElementByIdSafe(id) {
            const element = document.getElementById(id);
            if (!element) {
                console.warn(`Element with ID "${id}" not found.`);
            }
            return element;
        }

        /**
         * Updates the visibility of the API key hint.
         */
        function updateApiKeyHintVisibility() {
            if (!setupScreen.classList.contains('hidden')) {
                apiKeyHintLink.style.display = geminiApiKey ? 'none' : '';
            } else {
                apiKeyHintLink.style.display = 'none';
            }
        }

        /**
         * Updates UI elements based on the current language.
         */
        function updateUIForLanguage() {
            const t = translations[gameLanguage];

            const elementsToUpdate = [
                { id: 'gameTitle', text: t.gameTitle }, { id: 'labelNumPlayers', text: t.labelNumPlayers },
                { id: 'labelNumRounds', text: t.labelNumRounds }, { id: 'startGameBtn', text: t.startGameBtn },
                { id: 'labelTextPlayer', text: t.labelTextPlayer }, { id: 'labelTextRound', text: t.labelTextRound },
                { id: 'labelTextScore', text: t.labelTextScore }, { id: 'loadingText', text: t.loadingText },
                { id: 'endRoundBtn', text: t.endRoundBtn }, { id: 'gameEndTitle', text: t.gameEndTitle },
                { id: 'finalScoreTitle', text: t.finalScoreTitle }, { id: 'newGameBtnEnd', text: t.newGameBtnEnd },
                { id: 'messageBoxCloseBtn', text: t.messageBoxCloseBtn }, { id: 'settingsTitle', text: t.settingsTitle },
                { id: 'labelLanguage', text: t.labelLanguage },
                { id: 'labelDifficulty', text: t.labelDifficulty },
                { id: 'labelGeneralShowCorrectAnswersFeedback', text: t.labelGeneralShowCorrectAnswersFeedback },
                { id: 'infoGeneralShowCorrectAnswersFeedback', text: t.infoGeneralShowCorrectAnswersFeedback },
                { id: 'labelGenrePrompt', text: t.labelGenrePrompt }, { id: 'genreHint', text: t.genreHint },
                { id: 'labelGeminiApiKey', text: t.labelGeminiApiKey }, { id: 'apiKeyHint', text: t.apiKeyHint },
                { id: 'apiKeyHintLink', text: t.apiKeySetupLink },
                { id: 'getApiKeyLink', text: t.getApiKeyLink }, { id: 'newGameBtnSettings', text: t.newGameBtnSettings },
                { id: 'closeSettingsBtn', text: t.closeSettingsBtn }, { id: 'confirmationTitle', text: t.confirmationTitle },
                { id: 'confirmationText', text: t.confirmationText }, { id: 'confirmYesBtn', text: t.confirmYes },
                { id: 'confirmNoBtn', text: t.confirmNo }, { id: 'roundSummaryTitle', text: t.roundSummaryTitle },
                { id: 'continueGameBtn', text: t.continueGameBtn }, { id: 'rulesModalTitle', text: t.rulesModalTitle },
                { id: 'colorThemeTitle', text: t.colorThemeTitle }, { id: 'presetThemeLabel', text: t.presetThemeLabel },
                { id: 'presetThemeDefault', text: t.presetThemeDefault }, { id: 'presetThemeLight', text: t.presetThemeLight },
                { id: 'presetThemeDark', text: t.presetThemeDark }, { id: 'presetThemeCustom', text: t.presetThemeCustom },
                { id: 'customColorsTitle', text: t.customColorsTitle }, { id: 'resetColorsBtn', text: t.resetColorsBtn },
            ];
            
            elementsToUpdate.forEach(item => {
                const element = getElementByIdSafe(item.id);
                if (element) element.textContent = item.text;
            });
            
            // Update difficulty options
            const difficultyOptions = difficultySelect.options;
            difficultyOptions[0].textContent = t.difficultyEasy;
            difficultyOptions[1].textContent = t.difficultyMedium;
            difficultyOptions[2].textContent = t.difficultyHard;

            const colorLabels = {
                bodyBg: t.colorBodyBg, containerBg: t.colorContainerBg, inputBg: t.colorInputBg,
                text: t.colorText, 
                primaryBtnStart: t.colorPrimaryBtnStart,
                colorPrimaryBtnEnd: t.colorPrimaryBtnEnd, secondaryBtnBg: t.colorSecondaryBtnBg,
                wordCardBg: t.colorWordCardBg, wordCardBorder: t.colorWordCardBorder,
                wordCardSelectedBg: t.colorWordCardSelectedBg, wordCardSelectedBorder: t.colorWordCardSelectedBorder,
                wordCardIncorrectBg: t.colorWordCardIncorrectBg, wordCardIncorrectBorder: t.colorWordCardIncorrectBorder,
            };
            for (const key in colorLabels) {
                const label = document.querySelector(`label[for="color${key.charAt(0).toUpperCase() + key.slice(1)}"]`);
                if (label) label.textContent = colorLabels[key];
            }

            if (versionInfoElement) versionInfoElement.textContent = `${t.versionInfoText} ${GAME_VERSION}`;
            if (settingsBtn) settingsBtn.title = t.settingsTitle;
            if (rulesBtn) rulesBtn.title = t.rulesBtnText;

            document.querySelectorAll('.player-name-input').forEach(input => { input.placeholder = t.playerPlaceholder; });
            
            const updateConfirmButton = (inputField, confirmButton) => {
                if (!confirmButton) return;
                confirmButton.innerHTML = inputField.disabled ? `<i class="fas fa-pencil-alt"></i>` : `<i class="fas fa-check"></i>`;
                inputField.disabled ? confirmButton.classList.add('edit') : confirmButton.classList.remove('edit');
            };

            document.querySelectorAll('.player-name-input').forEach(input => {
                const confirmBtn = input.nextElementSibling;
                if (confirmBtn && confirmBtn.classList.contains('confirm-btn')) updateConfirmButton(input, confirmBtn);
            });

            if (genrePromptInput && confirmGenreBtn) updateConfirmButton(genrePromptInput, confirmGenreBtn);
            if (geminiApiKeyInput && confirmApiKeyBtn) updateConfirmButton(geminiApiKeyInput, confirmApiKeyBtn);

            updatePlayerIndicatorsBar();
        }

        /**
         * Displays a custom message box.
         */
        function showMessageBox(message, type = 'generic') {
            messageText.textContent = message;
            messageBox.dataset.messageType = type;
            messageBox.classList.remove('hidden');
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.classList.add('hidden');
            messageBox.dataset.messageType = '';
        }

        /**
         * Displays the confirmation modal.
         */
        function showConfirmationModal(message) {
            return new Promise(resolve => {
                confirmationText.textContent = message;
                confirmationModal.classList.remove('hidden');
                const handleConfirm = () => {
                    confirmationModal.classList.add('hidden');
                    confirmYesBtn.removeEventListener('click', handleConfirm);
                    confirmNoBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };
                const handleCancel = () => {
                    confirmationModal.classList.add('hidden');
                    confirmYesBtn.removeEventListener('click', handleConfirm);
                    confirmNoBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };
                confirmYesBtn.addEventListener('click', handleConfirm);
                confirmNoBtn.addEventListener('click', handleCancel);
            });
        }

        /**
         * Shuffles an array randomly.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        /**
         * Generates player name input fields.
         */
        function generatePlayerNameInputs() {
            const numPlayers = parseInt(numPlayersInput.value);
            playerNamesContainer.innerHTML = '';
            if (isNaN(numPlayers) || numPlayers < 1) return;

            const t = translations[gameLanguage];
            for (let i = 0; i < numPlayers; i++) {
                const div = document.createElement('div');
                div.className = 'flex flex-col items-start w-full';
                const label = document.createElement('label');
                label.htmlFor = `playerName${i}`;
                label.className = 'text-lg font-semibold mb-2';
                label.textContent = `${t.playerPlaceholder} ${i + 1}:`;

                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-with-confirm';
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `playerName${i}`;
                input.className = 'p-3 border border-gray-300 rounded-lg text-xl focus:ring-2 focus:ring-blue-400 player-name-input';
                input.placeholder = `${t.playerPlaceholder} ${i + 1}`;
                input.value = (players[i] && players[i].name) ? players[i].name : `${t.labelTextPlayer} ${i + 1}`;
                input.disabled = (players[i] && players[i].name) ? true : false;
                
                const confirmBtn = document.createElement('button');
                confirmBtn.className = 'confirm-btn' + (input.disabled ? ' edit' : '');
                confirmBtn.innerHTML = input.disabled ? `<i class="fas fa-pencil-alt"></i>` : `<i class="fas fa-check"></i>`;
                confirmBtn.id = `confirmPlayerName${i}`;
                confirmBtn.addEventListener('click', () => handleConfirmButtonClick(input, confirmBtn, `player${i}`));

                inputGroup.append(input, confirmBtn);
                div.append(label, inputGroup);
                playerNamesContainer.appendChild(div);
            }
        }

        /**
         * Handles the confirm button click for an input field.
         */
        function handleConfirmButtonClick(inputField, confirmButton, typeId) {
            const t = translations[gameLanguage];
            if (inputField.disabled) {
                inputField.disabled = false;
                confirmButton.innerHTML = `<i class="fas fa-check"></i>`;
                confirmButton.classList.remove('edit');
                inputField.focus();
            } else {
                const value = inputField.value.trim();
                if (value === "" && typeId.startsWith('player')) {
                    showMessageBox(t.playerNameRequired, 'generic');
                    return;
                }
                
                inputField.disabled = true;
                confirmButton.innerHTML = `<i class="fas fa-pencil-alt"></i>`;
                confirmButton.classList.add('edit');

                if (typeId.startsWith('player')) {
                    const playerIndex = parseInt(typeId.replace('player', ''));
                    if (players[playerIndex]) players[playerIndex].name = value;
                } else if (typeId === 'genre') {
                    genrePrompt = value;
                } else if (typeId === 'api') {
                    geminiApiKey = value;
                    localStorage.setItem('geminiApiKey', geminiApiKey);
                    updateApiKeyHintVisibility();
                }
            }
        }

        /**
         * Resets the game to its initial setup state.
         */
        function resetGame() {
            gameActive = false;
            const previousPlayerNames = players.map(p => p.name);
            players = [];
            for (let i = 0; i < gameConfig.numPlayers; i++) {
                players.push({
                    id: i, name: previousPlayerNames[i] || `${translations[gameLanguage].labelTextPlayer} ${i + 1}`,
                    totalScore: 0, roundEarnedPoints: 0, hasPlayedThisRoundTurn: false
                });
            }
            currentPlayerIndex = 0;
            currentRound = 1;
            selectedWords = [];
            correctWordsInRound = [];
            currentRoundCorrectCount = 0;
            currentTurnEarnedPoints = 0;
            usedQuestions.clear();
            currentQuestionData = null;

            setupScreen.classList.remove('hidden');
            gamePlayScreen.classList.add('hidden');
            gameEndScreen.classList.add('hidden');
            [roundSummaryModal, rulesModal, messageBox].forEach(el => el.classList.add('hidden'));
            generatePlayerNameInputs();
            updateUIForLanguage();
            updatePlayerIndicatorsBar();
            updateApiKeyHintVisibility();
        }

        // --- AI Integration ---
        async function generateQuestionAndWords() {
            loadingOverlay.classList.remove('hidden');
            const t = translations[gameLanguage];
            try {
                const apiKey = geminiApiKey || "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const genrePart = genrePrompt ? `The topic/genre is "${genrePrompt}".` : "";
                const usedQuestionsList = usedQuestions.size > 0 ? `Do not use any of the following questions: ${Array.from(usedQuestions).join("; ")}.` : "";
                
                let difficultyInstructions = "";
                const distortionClarification = gameLanguage === 'cs'
                    ? " Zkomoleniny by měly být chytré úpravy struktury slova, jako je změna, přidání nebo odebrání písmen, aby vzniklo věrohodně znějící, ale nesprávné slovo. Vyhněte se prosím jednoduchým gramatickým chybám, jako je záměna i/y nebo délek samohlásek (í/i)."
                    : " The distortions should be clever alterations of the word's structure, like changing, adding, or removing letters to create a plausible-sounding but incorrect word. Please avoid simple grammatical mistakes like swapping i/y or long/short vowels.";

                switch (difficulty) {
                    case "medium":
                        difficultyInstructions = "Create a mix of incorrect answers: some should be factually wrong but plausible, while others should be slightly distorted or misspelled versions of related (but still incorrect) concepts. For example, if the question is about Greek gods, a distorted incorrect answer could be 'Dijus' instead of 'Dionysus'." + distortionClarification;
                        break;
                    case "hard":
                        difficultyInstructions = "Create a challenging mix of incorrect answers. Some should be factually wrong but highly plausible. Others should be subtle distortions or misspellings of either correct or related incorrect concepts. For example, for the question 'What is the capital of France?', a distorted answer could be 'Lilon' (similar to 'Lyon'). Crucially, ensure that if a word is a distortion of another concept, the correct version of that concept is NOT present in either the correct or incorrect answer lists to avoid giving away the answer." + distortionClarification;
                        break;
                    case "easy":
                    default:
                        difficultyInstructions = "The incorrect answers should be clearly factually wrong, but still related to the question's topic.";
                        break;
                }

                const prompt = `Generate a JSON object for a word quiz in ${gameLanguage === 'cs' ? 'Czech' : 'English'}. It needs a "question", five "correct_answers", and five "incorrect_answers". Answers should be single words or short phrases. ${genrePart} ${difficultyInstructions} ${usedQuestionsList} IMPORTANT: Never include a correct answer and its distorted version in the same list. All 10 answers must be unique.`;
                
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                question: { type: "STRING" },
                                correct_answers: { type: "ARRAY", items: { type: "STRING" } },
                                incorrect_answers: { type: "ARRAY", items: { type: "STRING" } }
                            },
                            required: ["question", "correct_answers", "incorrect_answers"]
                        }
                    }
                };

                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const result = await response.json();

                const part = result.candidates?.[0]?.content?.parts?.[0];
                if (part) {
                    const parsedJson = JSON.parse(part.text);
                    if (parsedJson.question && parsedJson.correct_answers?.length === 5 && parsedJson.incorrect_answers?.length === 5) {
                        usedQuestions.add(parsedJson.question);
                        return parsedJson;
                    }
                    throw new Error(t.aiInvalidStructure);
                }
                throw new Error(result.error?.message || t.aiNoResponse);
            } catch (error) {
                console.error("Error generating question:", error);
                showMessageBox(`${t.aiError}${error.message}`, 'generic');
                throw error;
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        }

        // --- Game Logic ---
        function startGame() {
            const t = translations[gameLanguage];
            gameConfig.numPlayers = parseInt(numPlayersInput.value);
            gameConfig.numRounds = parseInt(numRoundsInput.value);

            if (isNaN(gameConfig.numPlayers) || gameConfig.numPlayers < 1) return showMessageBox(t.playerInvalidNum, 'generic');
            if (isNaN(gameConfig.numRounds) || gameConfig.numRounds < 1) return showMessageBox(t.roundInvalidNum, 'generic');

            let allNamesConfirmed = true;
            players = Array.from(document.querySelectorAll('.player-name-input')).map((input, index) => {
                const name = input.value.trim();
                if (name === "" || !input.disabled) allNamesConfirmed = false;
                return { id: index, name, totalScore: 0, roundEarnedPoints: 0, hasPlayedThisRoundTurn: false };
            });

            if (!allNamesConfirmed) return showMessageBox(t.playerNameRequired, 'generic');

            setupScreen.classList.add('hidden');
            gamePlayScreen.classList.remove('hidden');
            gameActive = true;
            currentRound = 1;
            currentPlayerIndex = 0;
            currentTurnEarnedPoints = 0;
            updatePlayerIndicatorsBar();
            startNewGameRound();
            updateApiKeyHintVisibility();
        }

        function clearWordCardFeedback() {
            wordsContainer.querySelectorAll('.word-card').forEach(card => {
                card.className = 'word-card rounded-xl p-4 sm:p-6 text-lg font-semibold cursor-pointer transition-all duration-200 ease-in-out flex-grow';
                card.style.pointerEvents = 'auto';
            });
        }

        function resetPointIndicators() {
            pointIndicators.forEach(indicator => indicator.classList.remove('achieved'));
        }

        function updatePointIndicator(index) {
            if (pointIndicators[index]) pointIndicators[index].classList.add('achieved');
        }

        function updatePlayerIndicatorsBar() {
            playerIndicatorsBar.innerHTML = '';
            players.forEach((player, index) => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-bar-item flex-shrink-0';
                let statusClass = 'waiting';
                if (index === currentPlayerIndex && gameActive) statusClass = 'current-player';
                else if (player.hasPlayedThisRoundTurn && gameActive) statusClass = 'played-in-round';
                playerItem.classList.add(statusClass);
                playerItem.innerHTML = `<span class="player-bar-name">${player.name}</span><span class="player-bar-score">${player.totalScore} ${translations[gameLanguage].labelTextScore.toLowerCase()}</span>`;
                playerIndicatorsBar.appendChild(playerItem);
            });
        }

        async function startNewGameRound() {
            if (!gameActive) return;
            difficulty = nextRoundDifficulty; // Apply difficulty for the new round
            generalShowCorrectAnswersFeedback = nextRoundGeneralShowCorrectAnswersFeedback;
            players.forEach(p => { p.hasPlayedThisRoundTurn = false; p.roundEarnedPoints = 0; });
            updatePlayerIndicatorsBar();

            if (!currentQuestionData) {
                try {
                    const data = await generateQuestionAndWords();
                    correctWordsInRound = data.correct_answers;
                    let allWords = data.correct_answers.map(w => ({ text: w, isCorrect: true }))
                                   .concat(data.incorrect_answers.map(w => ({ text: w, isCorrect: false })));
                    currentQuestionData = { question: data.question, allWords: shuffleArray(allWords) };
                } catch (error) { return endGame(); }
            }
            startPlayerTurn();
        }

        function startPlayerTurn() {
            if (!gameActive) return;
            const player = players[currentPlayerIndex];
            currentPlayerNameDisplay.textContent = player.name;
            currentRoundDisplay.textContent = currentRound;
            totalRoundsDisplay.textContent = gameConfig.numRounds;
            currentScoreDisplay.textContent = player.totalScore + player.roundEarnedPoints;
            clearWordCardFeedback();
            resetPointIndicators();
            wordsContainer.innerHTML = '';
            selectedWords = [];
            currentRoundCorrectCount = 0;
            currentTurnEarnedPoints = 0;
            endRoundBtn.disabled = false;
            questionDisplay.textContent = currentQuestionData.question;
            currentQuestionData.allWords.forEach(wordData => {
                const wordCard = document.createElement('div');
                wordCard.className = 'word-card rounded-xl p-4 sm:p-6 text-lg font-semibold cursor-pointer';
                wordCard.textContent = wordData.text;
                wordCard.dataset.isCorrect = wordData.isCorrect;
                wordCard.dataset.wordText = wordData.text;
                wordCard.addEventListener('click', () => handleWordClick(wordCard));
                wordsContainer.appendChild(wordCard);
            });
            updatePlayerIndicatorsBar();
        }

        function handleWordClick(clickedCard) {
            const wordText = clickedCard.dataset.wordText;
            if (!gameActive || selectedWords.includes(wordText)) return;
            
            const isCorrect = clickedCard.dataset.isCorrect === 'true';
            const t = translations[gameLanguage];
            wordsContainer.querySelectorAll('.word-card').forEach(card => card.style.pointerEvents = 'none');
            endRoundBtn.disabled = true;

            if (isCorrect) {
                clickedCard.classList.add('selected');
                selectedWords.push(wordText);
                currentRoundCorrectCount++;
                const pointsToAdd = scorePerCorrectChoice[currentRoundCorrectCount - 1] || 0;
                currentTurnEarnedPoints += pointsToAdd;
                updatePointIndicator(currentRoundCorrectCount - 1);
                currentScoreDisplay.textContent = players[currentPlayerIndex].totalScore + currentTurnEarnedPoints;

                if (currentRoundCorrectCount === 5) {
                    if (generalShowCorrectAnswersFeedback) applyCorrectAnswerFeedback();
                    showMessageBox(t.allCorrectMessage.replace('{points}', currentTurnEarnedPoints), 'turnEnd');
                } else {
                    wordsContainer.querySelectorAll('.word-card:not(.selected)').forEach(card => card.style.pointerEvents = 'auto');
                    endRoundBtn.disabled = false;
                }
            } else {
                clickedCard.classList.add('incorrect');
                if (generalShowCorrectAnswersFeedback) applyCorrectAnswerFeedback();
                currentTurnEarnedPoints = 0;
                showMessageBox(t.incorrectAnswerMessage(players[currentPlayerIndex].name), 'turnEnd');
            }
        }

        function applyCorrectAnswerFeedback() {
            wordsContainer.querySelectorAll('.word-card').forEach(card => {
                if (correctWordsInRound.includes(card.dataset.wordText)) card.classList.add('correct-feedback');
            });
        }

        function handleTurnEndMessageDismissal() {
            players[currentPlayerIndex].roundEarnedPoints += currentTurnEarnedPoints;
            currentTurnEarnedPoints = 0;
            players[currentPlayerIndex].hasPlayedThisRoundTurn = true;
            updatePlayerIndicatorsBar();
            clearWordCardFeedback();
            proceedToNextPlayerOrRoundSummary();
        }

        function proceedToNextPlayerOrRoundSummary() {
            if (currentPlayerIndex + 1 < players.length) {
                currentPlayerIndex++;
                showMessageBox(translations[gameLanguage].nextPlayerMessage(players[currentPlayerIndex].name), 'nextPlayer');
            } else {
                currentPlayerIndex = 0;
                currentQuestionData = null;
                showRoundSummaryModal();
            }
        }

        function showRoundSummaryModal() {
            const t = translations[gameLanguage];
            roundSummaryScores.innerHTML = '';
            const sortedPlayers = [...players].sort((a, b) => (b.totalScore + b.roundEarnedPoints) - (a.totalScore + a.roundEarnedPoints));
            sortedPlayers.forEach(player => {
                roundSummaryScores.innerHTML += `<p>${player.name}: ${t.roundSummaryScorePrefix}${player.totalScore + player.roundEarnedPoints} (${t.roundSummaryRoundPointsPrefix}${player.roundEarnedPoints})</p>`;
            });
            roundSummaryModal.classList.remove('hidden');
        }

        function continueGameAfterSummary() {
            roundSummaryModal.classList.add('hidden');
            players.forEach(player => {
                player.totalScore += player.roundEarnedPoints;
                player.roundEarnedPoints = 0;
                player.hasPlayedThisRoundTurn = false;
            });
            currentRound++;
            if (currentRound <= gameConfig.numRounds) {
                updatePlayerIndicatorsBar();
                startNewGameRound();
            } else {
                endGame();
            }
        }

        function endGame() {
            gameActive = false;
            gamePlayScreen.classList.add('hidden');
            gameEndScreen.classList.remove('hidden');
            const t = translations[gameLanguage];
            players.sort((a, b) => b.totalScore - a.totalScore);
            finalScoresDisplay.innerHTML = players.map((p, i) => `<p>${i + 1}. ${p.name}: ${p.totalScore}</p>`).join('');
            showMessageBox(t.gameFinishedMessage, 'gameEnd');
        }
        
        function openSettingsModal() {
            geminiApiKeyInput.value = geminiApiKey;
            languageSelect.value = gameLanguage;
            difficultySelect.value = nextRoundDifficulty; // NEW
            generalShowCorrectAnswersFeedbackToggle.checked = nextRoundGeneralShowCorrectAnswersFeedback;
            genrePromptInput.value = genrePrompt;

            const updateConfirmButton = (inputField, confirmButton) => {
                if (!confirmButton) return;
                confirmButton.innerHTML = inputField.disabled ? `<i class="fas fa-pencil-alt"></i>` : `<i class="fas fa-check"></i>`;
                inputField.disabled ? confirmButton.classList.add('edit') : confirmButton.classList.remove('edit');
            };
            updateConfirmButton(genrePromptInput, confirmGenreBtn);
            updateConfirmButton(geminiApiKeyInput, confirmApiKeyBtn);

            document.querySelector(`input[name="themePreset"][value="${currentTheme}"]`).checked = true;
            customColorsSection.classList.toggle('hidden', currentTheme !== 'custom');
            if (currentTheme === 'custom') {
                 for (const key in colorInputs) {
                    if (colorInputs[key]) {
                        colorInputs[key].value = customColors[key] || themes.light[key];
                        hexColorInputs[key].value = customColors[key] || themes.light[key];
                    }
                }
            }
            settingsModal.classList.remove('hidden');
        }

        // --- Event Listeners ---
        startGameBtn.addEventListener('click', startGame);
        endRoundBtn.addEventListener('click', () => {
            if (gameActive) showMessageBox(translations[gameLanguage].endRoundEarlyMessage(players[currentPlayerIndex].name, currentTurnEarnedPoints), 'turnEnd');
        });
        newGameBtnEnd.addEventListener('click', resetGame);
        messageBoxCloseBtn.addEventListener('click', () => {
            const type = messageBox.dataset.messageType;
            hideMessageBox();
            if (!gameActive && type !== 'gameEnd') return;
            if (type === 'turnEnd') handleTurnEndMessageDismissal();
            else if (type === 'nextPlayer') startPlayerTurn();
        });
        numPlayersInput.addEventListener('change', generatePlayerNameInputs);
        continueGameBtn.addEventListener('click', continueGameAfterSummary);
        decrementPlayersBtn.addEventListener('click', () => { if (numPlayersInput.value > 1) { numPlayersInput.value--; generatePlayerNameInputs(); } });
        incrementPlayersBtn.addEventListener('click', () => { numPlayersInput.value++; generatePlayerNameInputs(); });
        decrementRoundsBtn.addEventListener('click', () => { if (numRoundsInput.value > 1) numRoundsInput.value--; });
        incrementRoundsBtn.addEventListener('click', () => numRoundsInput.value++);
        settingsBtn.addEventListener('click', openSettingsModal);
        apiKeyHintLink.addEventListener('click', openSettingsModal);
        closeSettingsBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
        
        difficultySelect.addEventListener('change', () => { // NEW
            nextRoundDifficulty = difficultySelect.value;
            localStorage.setItem('difficulty', nextRoundDifficulty);
        });

        generalShowCorrectAnswersFeedbackToggle.addEventListener('change', () => {
            nextRoundGeneralShowCorrectAnswersFeedback = generalShowCorrectAnswersFeedbackToggle.checked;
            localStorage.setItem('generalShowCorrectAnswersFeedback', nextRoundGeneralShowCorrectAnswersFeedback.toString());
        });
        confirmGenreBtn.addEventListener('click', () => handleConfirmButtonClick(genrePromptInput, confirmGenreBtn, 'genre'));
        confirmApiKeyBtn.addEventListener('click', () => handleConfirmButtonClick(geminiApiKeyInput, confirmApiKeyBtn, 'api'));
        themePresetRadios.forEach(radio => radio.addEventListener('change', (e) => {
            const theme = e.target.value;
            customColorsSection.classList.toggle('hidden', theme !== 'custom');
            if (theme === 'custom') {
                customColors = { ...themes.light };
                Object.keys(colorInputs).forEach(key => {
                    colorInputs[key].value = customColors[key];
                    hexColorInputs[key].value = customColors[key];
                });
            }
            applyTheme(theme);
        }));
        Object.keys(colorInputs).forEach(key => {
            colorInputs[key].addEventListener('input', (e) => {
                customColors[key] = e.target.value;
                hexColorInputs[key].value = e.target.value;
                applyTheme('custom');
                document.querySelector('input[name="themePreset"][value="custom"]').checked = true;
            });
            hexColorInputs[key].addEventListener('input', (e) => {
                const color = e.target.value;
                if (/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color)) {
                    customColors[key] = color;
                    colorInputs[key].value = color;
                    applyTheme('custom');
                    document.querySelector('input[name="themePreset"][value="custom"]').checked = true;
                }
            });
        });
        resetColorsBtn.addEventListener('click', () => {
            customColors = { ...themes.light };
            Object.keys(colorInputs).forEach(key => {
                colorInputs[key].value = customColors[key];
                hexColorInputs[key].value = customColors[key];
            });
            applyTheme('custom');
            document.querySelector('input[name="themePreset"][value="custom"]').checked = true;
        });
        newGameBtnSettings.addEventListener('click', async () => {
            const confirmed = await showConfirmationModal(translations[gameLanguage].confirmationText);
            if (confirmed) {
                // Settings are now saved on change, so just apply them
                genrePrompt = genrePromptInput.value.trim();
                geminiApiKey = geminiApiKeyInput.value.trim();
                localStorage.setItem('geminiApiKey', geminiApiKey);
                gameLanguage = languageSelect.value;
                nextRoundDifficulty = difficultySelect.value; // ensure it's up to date
                localStorage.setItem('difficulty', nextRoundDifficulty);
                settingsModal.classList.add('hidden');
                resetGame();
            }
        });
        rulesBtn.addEventListener('click', () => rulesModal.classList.remove('hidden'));
        closeRulesBtn.addEventListener('click', () => rulesModal.classList.add('hidden'));

        // Initialize game on window load
        window.onload = function() {
            geminiApiKey = localStorage.getItem('geminiApiKey') || "";
            const storedFeedback = localStorage.getItem('generalShowCorrectAnswersFeedback');
            if (storedFeedback !== null) {
                nextRoundGeneralShowCorrectAnswersFeedback = JSON.parse(storedFeedback);
                generalShowCorrectAnswersFeedbackToggle.checked = nextRoundGeneralShowCorrectAnswersFeedback;
            }
            
            const storedDifficulty = localStorage.getItem('difficulty'); // NEW
            if (storedDifficulty) {
                nextRoundDifficulty = storedDifficulty;
                difficultySelect.value = storedDifficulty;
            }

            loadThemeSettings();
            resetGame();
        };
    </script>
</body>
</html>
